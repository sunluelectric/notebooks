\chapter{Database}

Database and \myabb{database manage systems}{DBMS} are introduced in this and consecutive chapters. Both relational and non-relational databases are covered. Tools and languages to manipulate databases, such as \myabb{structured query language}{SQL} for relational databases, are introduced.

\section{Relational Database}

\mync{Database}, in a broad view, refers to an organized collection of data of any format. In this sense, any file format that hosts information in a meaningful and explainable way, such as CSV, XML and JSON, is a database. These file formats often work fine when the data is stored in a centralized manner and its size small.

As the data size grows, the robustness and efficiency of storing and retrieving data become challenging, and different database models have been proposed to tackle it. Dedicated software, namely DBMS, is developed to manage and maintain the database and provide an interface for the users to create, retrieve, update and delete data. Different database models require different database engines and DBMS, and different DBMS may provide different interfaces for the users.

There are many database models available in the market. The most widely seen database models can be divided into two categories, namely the \mync{Relational Database}[RDB] and the non-relational databases.

Relational database was proposed in 1970s by IBM. Some important features of a relational database include the following.
\begin{itemize}
	\item Structure the data as ``relations'', which is a collection of tables, each consisting of a set of rows (also known as tuple/record) and columns (also known as attribute/field).
	\item For each table, a primary key, either being a column or a combination of several columns, is defined that can uniquely distinguish a row from others.
	\item Provide relational operations that manipulate the data in the tables, for example, joining tables together and aligning them using an attribute.
\end{itemize}

\mync{SQL}, a domain-specific language, can be used in managing RDB and interfacing relational DBMS.  Most commercialized \myabb{RDB management systems}{RDBMS} adopt SQL as the query language. There are alternatives, but they are rarely used compared to SQL. There is a evolving standard on what operations should an RDBMS support using SQL. The latest version as of this writing is \verb|SQL:2023|.

Examples of relational databases include \textit{Oracle}, \textit{MySQL}, \textit{Microsoft SQL Server}, \textit{MariaDB}, \textit{IBM Db2}, \textit{Amazon Redshift}, \textit{Amazon Aurora} and \textit{PostgreSQL}.

An example of a table used in RDB is given in Table \ref{ch:db:tab:relationaldbexample}. The table has a name \verb|user| and 4 attributes \verb|user_id|, \verb|user_email|, \verb|membership| and \verb|referee_id|. A table should have an attribute (or a set of attributes) defined as the primary key. In this example, \verb|user_id| is assigned to be the primary key as denoted by the asterisk. The primary key is used to uniquely identify a row in the table. A primary key can consist a single column or multiple columns. When a primary key is composed of multiple columns, it is called a composite key. A table should have one and only one primary key.

Depending on the meaning behind the primary key, it can be divided into two types, namely surrogate key and natural key. A surrogate key is like a serial number or an incremental ID which serves only for recording and distinguishing rows and does not have a physical meaning. In contrast, a natural key such as a timestamp, email, citizenship IC number, reflects some meaningful information in the real world.

\begin{table}
	\centering \caption{An example of a relational database table.} \label{ch:db:tab:relationaldbexample}
	\begin{tabular}{|c|c|c|c|}
		\hline
		\multicolumn{4}{|c|}{user} \\ \hline
		\verb|user_id|$^*$ & \verb|user_email| & \verb|membership| & \verb|referee-id| \\ \hline
		sunlu & sunlu@xxx.com & premium & NULL \\ \hline
		xingzhe & xingzhe@yyy.com & basic & sunlu \\ \hline
		\ldots & \ldots & \ldots & \ldots \\ \hline
	\end{tabular}
\end{table}

A foreign key is the attribute(s) that link a table to another table. It is often the primary key of another table that in some way links to this table. For example, consider another table \verb|membership_type| as defined in Table \ref{ch:db:tab:relationaldbexampleanother}. In the first Table \ref{ch:db:tab:relationaldbexample}, column \verb|membership| can be a foreign key which points to \verb|membership_type| in the second Table \ref{ch:db:tab:relationaldbexampleanother}.

\begin{table}
	\centering \caption{A second database table in the example.} \label{ch:db:tab:relationaldbexampleanother}
	\begin{tabular}{|c|c|c|}
		\hline
		\multicolumn{3}{|c|}{membership} \\ \hline
		\verb|membership_type| & \verb|monthly_price| & \verb|annual_price| \\ \hline
		none & 0 & 0 \\ \hline
		basic & 5 & 50 \\ \hline
		premium & 10 & 80 \\ \hline
	\end{tabular}
\end{table}

The introducing of foreign key helps to maintain the consistency and integrity of the database. For example, when adding a new member to Table \ref{ch:db:tab:relationaldbexample}, the DBMS will first check whether the membership type is registered in Table \ref{ch:db:tab:relationaldbexampleanother}. If not, the insert operation will be rejected. This guarantees that all registered members have valid membership types.

Notice that a table can have multiple foreign keys. The foreign key can not only relate a table to another, but also relate a table to itself. For example, the ``referee-id'' attribute in Table \ref{ch:db:tab:relationaldbexample} could be the foreign key that links to ``user-id'' of the same table.

\section{Non-Relational Database}

Non-relational databases (NoSQL databases) gained their popularity in the $2000$s. In contrast to RDBs, NoSQL databases do not store data in tables like an RDB, but in key-value pairs, graphs, documents, or other formats. They are more flexible, efficient and easier to use in some applications than an RDB. Examples of NoSQL databases include \textit{Redis}, \textit{Azure CosmosDB}, \textit{Oracle NoSQL Database}, \textit{Amazon DynamoDB}, \textit{MongoDB}, \textit{AllegroGraph} and many more.

Unlike SQL which applies to almost all RDBMS, there is no universally adopted language for NoSQL DBMS. Each NoSQL DBMS often has its unique query language tailored to its specific data model. We use ``NoSQL'' to refer to a collective set of (very different and not interchangeable) languages used for NoSQL databases management. It is impossible to cover all the different types of NoSQL databases and their corresponding DBMS manipulation languages in this notebook. Only brief introductions to some example databases are given in later chapters.

Database services, both RDB and NoSQL, have become critical to our daily life and they are massively deployed on servers. In many applications they work together to deliver the service.

\section{Structured Query Language}

As of this writing, RDB is the most commonly used database, and SQL is its standard manipulating and querying language. They are introduced below.

\subsection{RDB Naming Conventions} \label{ch:db:subsec:tables}

It is recommended that the following naming conventions be applied to databases, tables and columns.
\begin{itemize}
\item General rules:
\begin{itemize}
\item Use natural collective terms over plurals, for example, ``staff'' over ``employees''.
\item Use only letters, numbers, and underscores.
\item Begin with a letter and may not end with an underscore.
\item Avoid using abbreviations unless commonly understood.
\item Avoid using prefixes.
\end{itemize}
\item Table:
\begin{itemize}
	\item Do NOT use the same name for a table and one of its columns.
	\item Do NOT concatenate two table names to create a third relationship table.
\end{itemize}
\item Column:
\begin{itemize}
	\item Use singular name for columns.
	\item Avoid using over simplified terms such as ``id''.
	\item Use only lowercase if possible.
\end{itemize}
\item Alias:
\begin{itemize}
	\item Use keyword \verb|AS| to indicate an alias.
	\item The correlation name should be the first letter of each word of the object name.
	\item If there is already the same correlation name, append a number.
\end{itemize}
\item Stored procedure: always contain a verb in the name of a stored procedure.
\item Uniform suffixes:
\begin{itemize}
	\item \verb|_id|: primary key.
	\item \verb|_status|: flag values.
	\item \verb|_total|: the total number of a collection of values.
	\item \verb|_num|: a number.
	\item \verb|_date|: a date.
	\item \verb|_name|: the name of a person or a product.
\end{itemize}
\end{itemize}

\subsection{General Introduction to SQL}

SQL is the most widely used language for interacting with DBMS for data query and maintenance. SQL is very powerful and flexible in its full capability, and it is hardly possible to cover everything in one section. Hence, in this section only the basic SQL operations are introduced.

Notice that the support of different DBMS to SQL may differ slightly. This is because an DBMS may (in fact, very likely) fail to adopt everything in the latest SQL standard. However, most of the commands especially the widely used ones such as creating tables, inserting rows and most of the querying, shall be universally consistent.

SQL is a hybrid language consisting of the following 4 sub-languages.
\begin{itemize}
  \item Data query language: query information and metadata of a database.
  \item Data definition language: define database schema.
  \item Data control language: control user access and permission to a database.
  \item Data manipulation language: insert, update and delete data from a database.
\end{itemize}

SQL supports variety of data types, and different DBMS may cover slightly different data types. Some of the most commonly used data types are summarized in Table \ref{ch:db:tab:sqldatatypes}. Nowadays, many DBMS supports more complicated types such as objects (the associated database is also known as the object-relational database), and many more. For the full list of data types that a DBMS supports, check the manuals and documents of that DBMS.

\begin{table}
	\centering \caption{Widely used SQL data types.}\label{ch:db:tab:sqldatatypes}
	\begin{tabularx}{\textwidth}{lX}
		\hline
		Data Type & Description \\ \hline
		INT/INTEGER & Integer, with a range of -2147483648 to 2147483647. When marked ``UNSIGNED'', the range becomes 0 to 4294967295. Some relevant data types are TINYINT, SMALLINT, MEDIUMINT, and BIGINT, which have different ranges. \\ 
		DEC/DECIMAL(size,d) & An exact fixed-point number. The total number of digits and the number of digits after decimal point are specified by ``size'' and ``d'', respectively. Some relevant data types are DOUBLE(size,d), which can also be used to specify a floating point. Notice that DEC/DECIMAL is usually preferable in most occasions. \\ 
		CHAR(size) & A fixed length string with the specified length in characters. \\ 
		VARCHAR(size) & A variable length string, with the specified maximum string length in characters. \\ 
		BOOL/BOOLEAN & This is essentially a 1-digit integer, where 0 stands for ``false'' and otherwise ``true''. \\ 
		BLOB & A binary large object with maximum 65535 bytes. \\ 
		DATE & A date by format ``YYYY-MM-DD''. \\ 
		TIME & A time by format ``hh:mm:ss''. \\ 
		DATETIME & A combination of date and time by format ``YYYY-MM-DD hh:mm:ss''. \\ 
		TIMESTAMP & A timestamp that measures the number of seconds since the Unix epoch. The format is ``YYYY-MM-DD hh:mm:ss''. Unlike DATETIME which is meaningful only if the timezone is known, TIMESTAMP does not rely on timezone. \\ \hline
	\end{tabularx}
\end{table}

SQL defines reserved keywords for database manipulation. The keywords have specific meanings and cannot be used as user-defined variable names. Commonly used SQL keywords are summarized in Tables \ref{ch:db:tab:sqlkeywords1}, \ref{ch:db:tab:sqlkeywords2} and \ref{ch:db:tab:sqlkeywords3}.

\begin{table}
	\centering \caption{Widely used SQL keywords (part 1: names).}\label{ch:db:tab:sqlkeywords1}
	\begin{tabularx}{\textwidth}{lX}
		\hline
		Keyword & Description \\ \hline
		CONSTRAINT & A constraint that limits the value of a column. \\ 
		DATABASE & A database. \\ 
		TABLE & A table. \\ 
		COLUMN & A column (attribute, field) of a table. \\ 
		VIEW & A view, which is a virtual table that does not store data by itself but only reflects the base tables data. \\ 
		INDEX & An index, which is a pre-scan of specific column(s) of a table and can be used to speed up future queries related to the column(s). Notice that unlike a view, an index needs to be stored together with the table. \\ 
		PRIMARY KEY & The primary key of a table. \\ 
		FOREIGN KEY & A foreign key defined in a table that links to a (different) table. \\ 
		PROCEDURE & A procedure that defines a list of database operations to be executed one after another \\ \hline
	\end{tabularx}
\end{table}

\begin{table}
	\centering \caption{Widely used SQL keywords (part 2: actions).}\label{ch:db:tab:sqlkeywords2}
	\begin{tabularx}{\textwidth}{lX}
		\hline
		Keyword & Description \\ \hline
		CREATE & Create a database (CREATE DATABASE), a table (CREATE TABLE), a view (CREATE VIEW), an index (CREATE INDEX) or a procedure (CREATE PROCEDURE). \\ 
		ADD & Add a column in an existing table, or a constraint to an existing column. \\ 
		ALTER & Modify columns in a table (ALTER TABLE), or a data type of a column (ALTER COLUMN). \\ 
		SET & Specify the columns and values to be updated in a table. \\ 
		DROP & Delete a column (DROP COLUMN), a constraint (DROP CONSTRAINT), a database (DROP DATABASE), an index (DROP INDEX), a table (DROP TABLE), or a view (DROP VIEW). \\ 
		CHECK & Define a constraint that limits the value that can be placed in a column. \\ 
		DEFAULT & Define a default value for a column. \\ 
		INSERT INTO & Insert a new row into a table. \\ 
		UPDATE & Update an existing row in a table. \\ 
		DELETE & Delete a row from a table. \\ 
		EXEC & Executes a stored procedure. \\ \hline
	\end{tabularx}
\end{table}

\begin{table}
	\centering \caption{Widely used SQL keywords (part 3: queries).}\label{ch:db:tab:sqlkeywords3}
	\begin{tabularx}{\textwidth}{lX}
		\hline
		Keyword & Description \\ \hline
		SELECT & Query data from a database. Relevant combinations are SELECT DISTINCT which returns only distinct values; SELECT INTO which copies data from one table into another; SELECT TOP which returns part of the results. \\ 
		AS & Assign an alias to a column or table. \\ 
		FROM & Specify the table where the query is run. \\ 
		WHERE & Filter results that fulfill a specified condition. \\ 
		IN & Specify multiple values in a WHERE clause. \\ 
		AND & Select rows where both conditions are true. \\ 
		OR & Select rows where either condition is true. \\ 
		ALL & Return true if all followed sub-query values meet the condition. \\ 
		ANY & Return true if any followed sub-query value meet the condition. \\ 
		BETWEEN & Select values within a given range. \\ 
		ORDER BY & Sort the results in ascending or descending order. \\ 
		JOIN & Join tables for query. Relevant combinations are OUTER JOIN, INNER JOIN, LEFT JOIN and RIGHT JOIN. \\ 
		EXISTS & Tests for the existence of any record in a sub-query. \\ 
		GROUP BY & Groups the result set when using aggregate functions (COUNT, MAX, MIN, SUM, AVG). \\ 
		UNION & Combines the result sets of multiple select statements. \\
		 \hline
	\end{tabularx}
\end{table}

\subsection{General Syntax}

Notice that different DBMS may use slightly different syntax for the same or similar function. In the rest of the chapter, unless otherwise mentioned, MySQL/MariaDB syntax is used. 

All SQL commands shall end with a semicolon ``\verb|;|''.

The programming of SQL shall follow the following common practices wherever possible. This helps to maintain the good quality and portability of the code.
\begin{itemize}
	\item Use standard SQL functions over user-defined functions wherever possible for better portability.
	\item Do NOT use object-oriented design principles in SQL and database schema wherever possible.
	\item Use UPPERCASE for keywords.
	\item Use \verb|/*<comments>*/| to add comments to the code, otherwise precede comments with \verb|-- <comments>| and finish them with a new line.
\end{itemize}

The naming of database, tables and columns shall follow conventions introduced in Section \ref{ch:db:subsec:tables}.

During the coding, follow the following rules.
\begin{itemize}
	\item Use spaces to align the codes.
	\item Use a space before and after equals (=), and after commas (,).
	\item Use BETWEEN and IN, instead of combining multiple AND and OR clauses.
\end{itemize}

When creating a table, follow the following rules.
\begin{itemize}
	\item Choose standard SQL data types wherever possible.
	\item Specify default values and set up constraints, and put them close to the declaration of the associated column name.
	\item Assign primary key carefully and keep it simple.
	\item Specify the primary key first right after the CREATE TABLE statement.
	\item Implement validation. For example, for a numerical value, use CHECK to prevent incorrect values.
\end{itemize}

\subsection{Database Manipulation}

To list down all the databases running on the server, use
\begin{lstlisting}
SHOW DATABASES;
\end{lstlisting}
To create a database, use
\begin{lstlisting}
CREATE DATABASE <database-name>;
\end{lstlisting}
To select a database, use
\begin{lstlisting}
USE <database-name>;
\end{lstlisting}
To delete a database, use
\begin{lstlisting}
DROP DATABASE <database-name>;
\end{lstlisting}

\subsection{Table Manipulation}

Tables are the fundamental components in an RDB. An example of creating a table using SQL is given below
\begin{lstlisting}
CREATE TABLE <table_name> (
    PRIMARY KEY (<column_name>),
    <column_name_1>    <data-type>    <constraint>,
    <column_name_2>    <data-type>    <constraint>,
                       CONSTRAINT <constraint-name-1>
                       CHECK(<constraint-rule>),
                       CONSTRAINT <constraint-name-2>
                       CHECK(<constraint-rule>)
);
\end{lstlisting}
where in this demonstrative table, 2 columns and 2 constraints are defined.

The \verb|<constraint>| that comes after the data type of a column is used to set an additional restriction to the data in the table. When such restriction is violated, an error would raise to stop the operation. For example, if \verb|NOT NULL| is set as a constraint, then when inserting a row to the table later, the user cannot input NULL for that specific column. Notice that the ``primary key'' can also be set as a constraint named \verb|PRIMARY KEY| using this syntax, although it is a better practice to use \verb|PRIMARY KEY (<column-name>)|.

Commonly used such constraints are summarized into Table \ref{ch:db:tab:constraints}.
\begin{table}
	\centering \caption{Commonly used constraints.}\label{ch:db:tab:constraints}
	\begin{tabularx}{\textwidth}{lX}
		\hline
		Constraint & Description \\ \hline
		\verb|NOT NULL| & Not allowed to be NULL. \\ 
		\verb|UNIQUE| & Not allowed to have duplicated values. \\ 
        \verb|PRIMARY KEY| & Set as primary key, thus, must be not NULL and must remain unique. \\ 
        \verb|FOREIGH KEY| & Set as foreign key. \\ 
        \verb|DEFAULT <value>| & Set a default value. \\ 
        \verb|AUTO_INCREMENT = <value>| & Each time a new row is inserted and NULL or 0 is set for this column, instead of set the column to NULL or 0, automatically generate the next sequence number. The starting value is defined by \verb|<value>| which by default is 1. \\
		 \hline
	\end{tabularx}
\end{table}
As shown by Table \ref{ch:db:tab:constraints}, a default value can be assigned to a column by using the \verb|DEFAULT <value>| constraint. When inserting a new row, the column of that row will be assigned to its default value if no other value is assigned. If no such statement is provided for a column, its default value is NULL.

Upon creation of a table, its basic schema can be reviewed using
\begin{lstlisting}
DESCRIBE <table-name>;
\end{lstlisting}
To list down existing tables, use
\begin{lstlisting}
SHOW TABLES;
\end{lstlisting}
To delete a table, use
\begin{lstlisting}
DROP TABLE <table-name>;
\end{lstlisting}

To edit the column of a table, use either of the following
\begin{lstlisting}
ALTER TABLE <table-name>
ADD <column-name> <data-type>; -- add new column
ALTER TABLE <table-name>
DROP COLUMN <column-name>; -- drop column
ALTER TABLE <table-name>
RENAME COLUMN <old-name> TO <new-name>; -- rename column
ALTER TABLE <table-name>
MODIFY COLUMN <column-name> <data-type>; -- modify column data type (depending on DBMS, syntax may differ)
\end{lstlisting}
or
\begin{lstlisting}
ALTER TABLE <table-name>
ADD CONSTRAINT <constraint-name> CHECK(<constraint-rule>); -- add constraint
ALTER TABLE <table-name>
DROP CONSTRAINT <constraint-name>; -- drop constraint
\end{lstlisting}
Notice that it is possible to change the primary key using the above syntax because essentially the primary key is treated as a constraint named ``primary''. It is not recommended to do so in general.

The foreign key is a key used to point to another table, in many cases other table's primary key. Therefore, the foreign key can be nominated only after the other table has been created. Declare foreign key upon creation of a table as follows. As mentioned, to do this, the other tables must be created beforehand. Two methods to declare a foreign key are shown below.
\begin{lstlisting}
CREATE TABLE <table-name> (
    PRIMARY KEY (<column-name>),
    <column-1>    <data-type>    <constraint>,
    <column-2>    <data-type>    <constraint>,
                  CONSTRAINT <constraint-name-1>
                  CHECK(<constraint-rule>),
                  CONSTRAINT <constraint-name-2>
                  CHECK(<constraint-rule>),
    FOREIGN KEY (<column-name>) REFERENCES <target-table-name>(<target-column-name>), -- method 1
                  CONSTRAINT <constraint-name-3>
                  FOREIGN KEY (<column name>)
                  REFERENCES <target-table-name>(<target-column-name>) -- method 2
);
\end{lstlisting}
where, as can be seen, foreign key is treated as a constraint in the table.

To define a foreign key in an existing table, use
\begin{lstlisting}
ALTER TABLE <table-name>
ADD FOREIGN KEY (<column name>) REFERENCES <referred-table-name>(<referred-column-name>); -- one way
ALTER TABLE <table-name>
ADD CONSTRAINT <constraint-name> FOREIGN KEY (<column name>) REFERENCES <referred-table-name>(<referred-column-name>); -- another way
\end{lstlisting}
To drop a foreign key, use
\begin{lstlisting}
ALTER TABLE <table-name>
DROP CONSTRAINT <constraint-name>;
\end{lstlisting}

There are variety ways of checking the constraints names of a table. An example is given below.
\begin{lstlisting}
SELECT TABLE_NAME, CONSTRAINT_TYPE, CONSTRAINT_NAME
FROM information_schema.table_constraints
WHERE table_name=<table-name>;
\end{lstlisting}

One thing to notice is that upon creation of a foreign key, the referred column becomes the ``parent'' and the foreign key becomes a ``child''. As long as the child exists, the parent cannot be removed from its table. This helps to protect the schema of the database. Should there be any quest to break the schema, this restriction can be overwritten. When defining the foreign key, add an additional claim ``ON DELETE SET NULL'' or ``ON DELETE CASCADE'' as follows.
\begin{lstlisting}
FOREIGN KEY (<column name>) REFERENCES <referred-table-name>(<referred-column-name>) ON DELETE SET NULL
FOREIGN KEY (<column name>) REFERENCES <referred-table-name>(<referred-column-name>) ON DELETE CASCADE
\end{lstlisting}
in the first scenario, the child foreign key will be set to NULL, while in the second scenario, the child relevant rows will be removed.

\subsection{Row Manipulation}

To insert a row into a table, use
\begin{lstlisting}
INSERT INTO <table-name> VALUES (<content>, <content>, ...);
\end{lstlisting}
where the contents shall follow the field sequence as shown by the \verb|DESCRIBE <table-name>| command. To specify the column name while inserting a row, use
\begin{lstlisting}
INSERT INTO <table-name>(<column-name>, <column-name>, ...) VALUES (<content>, <content>, ...);
\end{lstlisting}
Notice that it is also possible to populate multiple rows of a table using one command as follows.
\begin{lstlisting}
INSERT INTO <table-name>(<column-name>, <column-name>, ...)
VALUES (<content>, <content>, ...),
       (<content>, <content>, ...),
       (<content>, <content>, ...);
\end{lstlisting}
where 3 rows are inserted into the table.

Notice that if a foreign key bound exists between two tables, when inserting a row to the child table, the foreign key value of this row must already be defined in the parent table.

Use the following command to query all items in a table, which can be used to check whether the row is added to the table correctly.
\begin{lstlisting}
SELECT * FROM <table-name>;
\end{lstlisting}

To modify the attributes of specific row(s), use
\begin{lstlisting}
UPDATE <table-name>
SET <column-name> = <value>, ...
WHERE <filter-criteria>;
\end{lstlisting}
where \verb|<filter-critera>| is used to filter the rows to which the update is carried out. Commonly used filter criteria are a set of \verb|<cloumn-name> = <value>| separated by \verb|AND| and \verb|OR|. The filter criteria can be set very flexibly and more details are given in later sections. Notice that it is possible to change multiple column values together, by stacking multiple \verb|<column-name> = <value>| separated by ``,''. Similarly, to delete rows from a table, use
\begin{lstlisting}
DELETE FROM <table-name>
WHERE <filter-criteria>;
\end{lstlisting}

Notice that if filter criteria is not specified, i.e., if \verb|WHERE| is missing, all items in the table will be affected.

\subsection{Query}

A typical query looks like the following and it returns the data in a table-like format.
\begin{lstlisting}
SELECT <column-or-statistics>
FROM <table-name-or-combination>
GROUP BY <column-name>
WHERE <filter-criteria>
ORDER BY <column-name>, ...
LIMIT <number>;
\end{lstlisting}
where
\begin{itemize}
\item \verb|<column-or-statistics>| describes the columns to be returned, and specifies the returning information format.
\item \verb|<table-name-or-combination>| describes the source of the information, either being a table, or a joint of multiple tables.
\item \verb|GROUP BY| \verb|<column-name>| groups rows with the same value of the specified column into ``summary rows''.
\item \verb|<filter-condition>| defines the filter criteria and only rows meet the criteria are returned.
\item \verb|ORDER BY <column-name>| allows the items to be returned in a specific order based on ascending/descending order. It is worth mentioning that the \verb|<column-name>| here does not need to appear in the selected returns, and it can be multiple columns separated by ``,''. Use \verb|ASC| (default) or \verb|DESC| after each \verb|<column-name>| to specify ascending or descending order.
\item \verb|LIMIT <number>| restricts the maximum number of rows to be returned.
\end{itemize}
Notice that \verb|SELECT| and \verb|FROM| statements are compulsory in all queries, \verb|WHERE| statement very widely used, and other statements optional case by case.

More details are given below.

The statement \verb|<column-or-statistics>| mainly controls the information to be returned. Commonly seen selected items in \verb|<column-or-statistics>| are summarized as follows.
\begin{itemize}
  \item \verb|*| (asterisk): return all columns.
  \item \verb|<column-name>|: return selected columns.  When multiple fields are returned, use bracket \verb|(<col1>, <col2>, ...)|. The same applies to other return formats below.
  \item \verb|<table-name>.<column-name>|: return selected columns, and to avoid ambiguity, specify table name with the column name. This is useful when the source of data is a joint of multiple tables, some of which share the same column name.
  \item \verb|<column-name> AS <alias>|: return selected columns, and use alias in the returns.
  \item \verb|DISTINCT <column-name>|: return only distinct rows.
  \item \verb|COUNT()|, \verb|SUM()|, \verb|MIN()|, \verb|MAX()|, \verb|AVG()|: return aggregate function of a column instead of all the items in that column. They can be used along with DISTINCT, for example, \verb|COUNT(DISTINCT <column-name>, ...)|.
  \item Simple calculations to the above result, for example \verb|1.5*<column-name>|. Commonly used arithmetic operations are \verb|+|, \verb|-|, \verb|*|, \verb|/|, \verb|%|, \verb|DIV| (integer division).
\end{itemize}
When the column is of date time type or interval type, it is possible to use \verb|EXTRACT()| to select a field of the timestamp or interval. For example,
\begin{lstlisting}
SELECT EXTRACT(YEAR FROM birthday) AS year FROM customer;
\end{lstlisting}
would look into table \verb|customer|, focus on column \verb|birthday| which should be a datetime type, and extract only \verb|year| from the datetime to return the result.

The statement \verb|<table-name-or-combination>| mainly indicates the source table(s). It can be a single table, a joint of multiple tables, or a nest query. More details about joint of multiple tables are illustrated below.

Consider the following example, where two tables are given as follows.
\begin{lstlisting}
> SELECT * FROM test;
+---------+---------+---------+
| test_id | value_1 | value_2 |
+---------+---------+---------+
|       1 | a       |      10 |
|       2 | a       |      20 |
|       3 | a       |      30 |
|       4 | b       |     100 |
|       5 | b       |     200 |
|       6 | c       |    1000 |
|       7 | c       |    2000 |
+---------+---------+---------+

> SELECT * FROM test_join;
+--------------+---------+---------+---------+
| test_join_id | value_1 | value_2 | value_3 |
+--------------+---------+---------+---------+
| a            |      10 |      99 | alpha   |
| b            |     100 |     999 | bravo   |
| d            |   10000 |   99999 | delta   |
+--------------+---------+---------+---------+
\end{lstlisting}

There are different types of joins, namely ``inner join'' (or ``join''), ``left join'', ``right join'' and ``cross join''. They are introduced as follows.

The most intuitive join is the cross join. It returns everything in the two tables like a Cartesian product (that explains why cross join is also called Cartesian join), where the total number of columns are the sum of two tables, the number of rows the product of two tables, as shown below.
\begin{lstlisting}
> SELECT * FROM test CROSS JOIN test_join;
+---------+---------+---------+--------------+---------+---------+---------+
| test_id | value_1 | value_2 | test_join_id | value_1 | value_2 | value_3 |
+---------+---------+---------+--------------+---------+---------+---------+
|       1 | a       |      10 | a            |      10 |      99 | alpha   |
|       1 | a       |      10 | b            |     100 |     999 | bravo   |
|       1 | a       |      10 | d            |   10000 |   99999 | delta   |
|       2 | a       |      20 | a            |      10 |      99 | alpha   |
|       2 | a       |      20 | b            |     100 |     999 | bravo   |
|       2 | a       |      20 | d            |   10000 |   99999 | delta   |
|       3 | a       |      30 | a            |      10 |      99 | alpha   |
|       3 | a       |      30 | b            |     100 |     999 | bravo   |
|       3 | a       |      30 | d            |   10000 |   99999 | delta   |
|       4 | b       |     100 | a            |      10 |      99 | alpha   |
|       4 | b       |     100 | b            |     100 |     999 | bravo   |
|       4 | b       |     100 | d            |   10000 |   99999 | delta   |
|       5 | b       |     200 | a            |      10 |      99 | alpha   |
|       5 | b       |     200 | b            |     100 |     999 | bravo   |
|       5 | b       |     200 | d            |   10000 |   99999 | delta   |
|       6 | c       |    1000 | a            |      10 |      99 | alpha   |
|       6 | c       |    1000 | b            |     100 |     999 | bravo   |
|       6 | c       |    1000 | d            |   10000 |   99999 | delta   |
|       7 | c       |    2000 | a            |      10 |      99 | alpha   |
|       7 | c       |    2000 | b            |     100 |     999 | bravo   |
|       7 | c       |    2000 | d            |   10000 |   99999 | delta   |
+---------+---------+---------+--------------+---------+---------+---------+
\end{lstlisting}
where notice that \verb|CROSS JOIN| can be replaced by a comma ``,''.

In this example, \verb|value_1| from table \verb|test| and \verb|test_join_id| from table \verb|test_join| are corresponding with each other. In this context, the rows with inconsistent \verb|test.value_1| and \verb|test_join.test_join_id| is meaningless and shall be removed. This can be achieved by the following code.
\begin{lstlisting}
> SELECT * FROM test CROSS JOIN test_join
    -> where test.value_1 = test_join.test_join_id;
+---------+---------+---------+--------------+---------+---------+---------+
| test_id | value_1 | value_2 | test_join_id | value_1 | value_2 | value_3 |
+---------+---------+---------+--------------+---------+---------+---------+
|       1 | a       |      10 | a            |      10 |      99 | alpha   |
|       2 | a       |      20 | a            |      10 |      99 | alpha   |
|       3 | a       |      30 | a            |      10 |      99 | alpha   |
|       4 | b       |     100 | b            |     100 |     999 | bravo   |
|       5 | b       |     200 | b            |     100 |     999 | bravo   |
+---------+---------+---------+--------------+---------+---------+---------+
\end{lstlisting}
and this is equivalent to inner join (or simply, join)
\begin{lstlisting}
> SELECT * FROM test JOIN test_join
    -> ON (test.value_1 = test_join.test_join_id);
+---------+---------+---------+--------------+---------+---------+---------+
| test_id | value_1 | value_2 | test_join_id | value_1 | value_2 | value_3 |
+---------+---------+---------+--------------+---------+---------+---------+
|       1 | a       |      10 | a            |      10 |      99 | alpha   |
|       2 | a       |      20 | a            |      10 |      99 | alpha   |
|       3 | a       |      30 | a            |      10 |      99 | alpha   |
|       4 | b       |     100 | b            |     100 |     999 | bravo   |
|       5 | b       |     200 | b            |     100 |     999 | bravo   |
+---------+---------+---------+--------------+---------+---------+---------+
\end{lstlisting}
where \verb|ON (<table1.column-name> = <table2.column_name>)| is used to indicate the association. The number of columns remain unchanged compared with cross join, but the number of rows is reduced.

From table \verb|test| perspective, its rows regarding \verb|value_1| equals to ``a'' and ``b'' are fully included in the inner join results. However, the two rows regarding \verb|value_1=c| is omitted. This is because there is no corresponding row in the other table \verb|test_join| with \verb|test_join_id=c|.

It is possible to ``prevent'' information loss from table \verb|test| by adding these two rows back, with all the columns from table \verb|test_join| filled with NULL. This can be done by left join as follows.
\begin{lstlisting}
> SELECT * FROM test LEFT JOIN test_join
    -> ON (test.value_1 = test_join.test_join_id);
+---------+---------+---------+--------------+---------+---------+---------+
| test_id | value_1 | value_2 | test_join_id | value_1 | value_2 | value_3 |
+---------+---------+---------+--------------+---------+---------+---------+
|       1 | a       |      10 | a            |      10 |      99 | alpha   |
|       2 | a       |      20 | a            |      10 |      99 | alpha   |
|       3 | a       |      30 | a            |      10 |      99 | alpha   |
|       4 | b       |     100 | b            |     100 |     999 | bravo   |
|       5 | b       |     200 | b            |     100 |     999 | bravo   |
|       6 | c       |    1000 | NULL         |    NULL |    NULL | NULL    |
|       7 | c       |    2000 | NULL         |    NULL |    NULL | NULL    |
+---------+---------+---------+--------------+---------+---------+---------+
\end{lstlisting}
One can think of this as temporarily adding a new row to \verb|test_join| with \verb|test_join_id=c| and everything else NULL, before the inner joining.

The same idea applies to right join as well, as shown below.
\begin{lstlisting}
> SELECT * FROM test RIGHT JOIN test_join ON (test.value_1 = test_join.test_join_id);
+---------+---------+---------+--------------+---------+---------+---------+
| test_id | value_1 | value_2 | test_join_id | value_1 | value_2 | value_3 |
+---------+---------+---------+--------------+---------+---------+---------+
|       1 | a       |      10 | a            |      10 |      99 | alpha   |
|       2 | a       |      20 | a            |      10 |      99 | alpha   |
|       3 | a       |      30 | a            |      10 |      99 | alpha   |
|       4 | b       |     100 | b            |     100 |     999 | bravo   |
|       5 | b       |     200 | b            |     100 |     999 | bravo   |
|    NULL | NULL    |    NULL | d            |   10000 |   99999 | delta   |
+---------+---------+---------+--------------+---------+---------+---------+
\end{lstlisting}

Some DBMS supports ``outer join'', which is basically a union of the left and right join results. More about union is introduced later.

The statement \verb|<filter-condition>| applies filtering to the results. Commonly seen filter criteria \verb|<filter-condition>| are summarized as follows.
\begin{itemize}
  \item \verb|<column-name> = <value>|, where \verb|=| can be replaced by \verb|<| (less than), \verb|<=| (less than or equal to), \verb|>| (larger than), \verb|>=| (larger than or equal to) and \verb|<>| (not equal to).
  \item \verb|<column-name> IN (<value>, <value>, ...)|
  \item \verb|<column-name> BETWEEN <value> AND <value>|
  \item \verb|<column-name> LIKE <wildcards>|, which compares the column value (usually a string) with a given pattern.
  \item A combination of the above, with \verb|AND| and \verb|OR| joining everything together.
\end{itemize}

A bit more about wildcard query is introduced as follows. A wildcard character is a ``placeholder'' that represents a group of character(s). Most commonly used wildcard characters in the SQL context include
\begin{itemize}
  \item \verb|_|: any single character.
  \item \verb|%|: any string of characters (including empty string).
  \item \verb|[<c1><c2> ...]|: any single character given in the bracket.
  \item \verb|^[<c1><c2>...]|: any single character not given in the bracket.
  \item \verb|[<c1>-<c2>]|: any single character given within the range in the bracket.
\end{itemize}
Wildcard query can be applied to both CHAR and DATE/TIME types, as they can all be characterized as strings.

The \verb|GROUP BY| groups the rows with the same value of the specified column into ``summary rows''. In each summary row, aggregated information is collected. To further explain this, consider the following example.
\begin{lstlisting}
> SELECT * FROM test;
+---------+---------+---------+
| test_id | value_1 | value_2 |
+---------+---------+---------+
|       1 | a       |      10 |
|       2 | a       |      20 |
|       3 | a       |      30 |
|       4 | b       |     100 |
|       5 | b       |     200 |
|       6 | c       |    1000 |
|       7 | c       |    2000 |
+---------+---------+---------+
\end{lstlisting}
Running the following command gives
\begin{lstlisting}
> SELECT * FROM test GROUP BY value_1;
+---------+---------+---------+
| test_id | value_1 | value_2 |
+---------+---------+---------+
|       1 | a       |      10 |
|       4 | b       |     100 |
|       6 | c       |    1000 |
+---------+---------+---------+
\end{lstlisting}
From the result, it can be seen that summary rows have been created using \verb|GROUP BY|. In the returned table, \verb|value_1| has distinguished values. In this example, it simply picks up the first appearance of the rows in the original table that has distinguished \verb|value_1|, and a lot of information seems to be lost. However, it is worth mentioning that although not displayed, the aggregated information is included.

To verify the presence of the aggregated information, consider running the following command.
\begin{lstlisting}
> SELECT COUNT(*) FROM test GROUP BY value_1;
+----------+
| COUNT(*) |
+----------+
|        3 |
|        2 |
|        2 |
+----------+
\end{lstlisting}
From the result, we can see that the counted number of each summary row is returned. Similarly, the following SQL returns other aggregation information associated with each summary row.
\begin{lstlisting}
> SELECT value_1, COUNT(*), SUM(value_2) FROM test GROUP BY value_1;
+---------+----------+--------------+
| value_1 | COUNT(*) | SUM(value_2) |
+---------+----------+--------------+
| a       |        3 |           60 |
| b       |        2 |          300 |
| c       |        2 |         3000 |
+---------+----------+--------------+
\end{lstlisting}

Finally, \verb|ORDER BY| and \verb|LIMIT| controls the sequence and maximum number of returned rows, respectively.

The returns of multiple queries might be able to \verb|UNION| together, if they are union-compatible. Union simply means concatenate the tables vertically. To union the results, use
\begin{lstlisting}
SELECT <...>
UNION
SELECT <...>
UNION
SELECT <...>
...
SELECT <...>;
\end{lstlisting}
where inside \verb|<...>| are the original query statements. Notice that for the queries to be union-compatible, they must have the same number of columns with identical data type for the associated columns. The names of the column in the returns, if different, follow the first query result. Use alias \verb|AS| to change the names if needed. Duplicated rows in the union will be excluded. If duplications need to be included in the result, certain DBMS provides the \verb|UNION ALL| option.

SQL uses nest queries to add more flexibility. Nest queries plays as the intermediate steps to provide a temporary searching result, from which another query can be executed. Wherever a table name appears in the query, it can be replaced by a \verb|SELECT| statement nested in a bracket ``()''. A demonstrative example is given below. Consider the same tables \verb|test| and \verb|test_join| as follows.
\begin{lstlisting}
> SELECT * FROM test;
+---------+---------+---------+
| test_id | value_1 | value_2 |
+---------+---------+---------+
|       1 | a       |      10 |
|       2 | a       |      20 |
|       3 | a       |      30 |
|       4 | b       |     100 |
|       5 | b       |     200 |
|       6 | c       |    1000 |
|       7 | c       |    2000 |
+---------+---------+---------+

> SELECT * FROM test_join;
+--------------+---------+---------+---------+
| test_join_id | value_1 | value_2 | value_3 |
+--------------+---------+---------+---------+
| a            |      10 |      99 | alpha   |
| b            |     100 |     999 | bravo   |
| d            |   10000 |   99999 | delta   |
+--------------+---------+---------+---------+
\end{lstlisting}
A inner join is provided to the above tables. However, for each \verb|value_1| in the first table, the sum of the associated \verb|value_2|, instead of each individual row, is used. This can be achieved using
\begin{lstlisting}
> SELECT temp.value_1 AS type,
    ->          temp.sum_value_2 AS total_value,
    ->          test_join.value_1 AS minval,
    ->          test_join.value_2 AS maxval,
    ->          test_join.value_3 AS abbrev
    -> FROM (SELECT value_1,
    ->              SUM(value_2) AS sum_value_2
    ->       FROM test GROUP BY value_1) AS temp
    -> JOIN test_join
    -> ON (temp.value_1 = test_join.test_join_id);
+------+-------------+--------+--------+--------+
| type | total_value | minval | maxval | abbrev |
+------+-------------+--------+--------+--------+
| a    |          60 |     10 |     99 | alpha  |
| b    |         300 |    100 |    999 | bravo  |
+------+-------------+--------+--------+--------+
\end{lstlisting}
where notice that alias are quite some times to clarify the logics.

Nest queries can be popular in table joins as well as filter criteria, where the boundary of a variable can be obtained from a nest query.

\subsection{Trigger}

A trigger defines a set of operations to be carried out automatically when something happens to specified tables. For example, in any case a new row is added to a table, a trigger can automatically insert an associated record into another table.

There are mainly 3 types of triggers: DML trigger (triggered by \verb|INSERT|, \verb|UPDATE|, \verb|DELETE|, etc.), DDL trigger (triggered by \verb|CREATE|, \verb|ALTER|, \verb|DROP|, \verb|GRANT|, \verb|DENY|, \verb|REVOKE|, etc.), and CLR trigger (triggered by LOGON event).

A quick DML trigger can be defined as follows.
\begin{lstlisting}
CREATE TRIGGER <trigger-name>
    [BEFORE | AFTER] [INSERT | UPDATE | DELETE] ON <table-name>
    FOR EACH ROW <operation>;
\end{lstlisting}
where \verb|BRFORE| is often used to validate and modify data to be added to \verb|<table-name>|, and \verb|AFTER| is often used to trigger other changes consequent to this change.

In case multiple operations need to be defined, consider using
\begin{lstlisting}
DELIMITER $$
CREATE TRIGGER <trigger-name>
    [BEFORE | AFTER] [INSERT | UPDATE | DELETE] ON <table-name>
    FOR EACH ROW BEGIN
        <operation>;
        ...
        <operation>;
    END$$
DELIMITER ;
\end{lstlisting}
where \verb|DELIMITER $$| and \verb|DELIMITER ;| is used to temporarily change the delimiter for the \verb|BEGIN...END| statement. It is possible to build slightly complicated logics in the operations, for example to build conditional statements.

Use \verb|NEW| in the operation(s) to represent the rows that is added/updated/deleted from the \verb|table-name|.

Use the following to drop a trigger.
\begin{lstlisting}
DROP TRIGGER <trigger-name>;
\end{lstlisting}

\subsection{SQL Demonstrative Example}

An an example to demonstrate the use of SQL, a database is created from scratch. MariaDB is used as the DBMS in this example. More about MariaDB is introduced in later Section \ref{ch:db:sec:mariadb}. The database is used in the smart home project to track the resources obtained and consumed by the user. The resources in this context may refer to groceries bought from the supermarket, books purchased online, subscriptions of magazines and services, etc. For simplicity, the prompt is ignored in the rest of this section.

Check the existing databases as follows.
\begin{lstlisting}
SHOW DATABASES;
\end{lstlisting}
A database named \verb|smart_home| is created as follows.
\begin{lstlisting}
CREATE DATABASE smart_home;
\end{lstlisting}
Select the database as follows.
\begin{lstlisting}
USE smart_home;
\end{lstlisting}
With the above command, \verb|smart_home| is selected as the current database.

Based on the database schema design, a few tables need to be created. We shall start with creating \verb|asset|, \verb|accessory|, \verb|consumable| and \verb|subscription| tables as follows.

The \verb|asset| table is used to trace assets in the home. They are often expensive and comes with a serial number or a warranty number, and shall persist for a long time (a few years, at minimum). Examples of assets include beds, televisions, computers, printers, game consoles. The \verb|accessory| table is used to trace relatively cheaper accessories than assets. Though they are designed to last long, they may not have an serial number. Examples of accessories include books, charging cables, coffee cups. The \verb|consumable| table is used to trace items that is meant to be used up or expire. Examples of consumable items include food, shampoo, A4 printing paper. And finally the \verb|subscription| table is used to trace subscriptions of services. Examples of these services include software license (either permanent license or annual subscription license), magazine subscriptions, membership subscriptions, and digital procurement of a movie.

The serial number or warranty number for assets are used as the primary key of \verb|asset| table. For the other three tables, surrogate keys are used. Each table has a column \verb|product_type_id| that specifies the type of the item, such as ``television'', ``cooker'', ``fruit'', ``software''. The types in these tables are given by integer indices. A separate \verb|product_type| relates the indices with their associated meanings. The same applies to \verb|product_brand_id| and \verb|payment_method_id|.

Create \verb|asset| table as follows.
\begin{lstlisting}
CREATE TABLE asset (
	PRIMARY KEY (serial_num),
	serial_num                  VARCHAR(50)     NOT NULL,
	product_type_id             INT(5),
	product_brand_id            INT(5),
	product_name                VARCHAR(50)     NOT NULL,
	receipt_num                 VARCHAR(50),
	procured_date               DATE            NOT NULL DEFAULT (CURRENT_DATE),
	procured_price              DECIMAL(10,2),
	payment_method_id           INT(5),
	warranty_date_1             DATE            NOT NULL DEFAULT (CURRENT_DATE),
	warranty_date_2             DATE            NOT NULL DEFAULT (CURRENT_DATE),
	expire_date                 DATE            NOT NULL DEFAULT '9999-12-31',
	CONSTRAINT warranty_after_procured
	CHECK(warranty_date_1 >= procured_date AND warranty_date_2 >= warranty_date_1),
	CONSTRAINT expire_after_procured
	CHECK(expire_date >= procured_date)
);
\end{lstlisting}
where
\begin{itemize}
	\item \verb|serial_num|: the serial number, MAC number or registration ID that can be used to uniquely identify the asset.
	\item \verb|product_type_id|: type index.
	\item \verb|product_brand_id|: brand index.
	\item \verb|product_name|: full name of the product that can uniquely specify the asset on the market.
	\item \verb|receipt_num|: receipt and/or warranty number.
	\item \verb|procured_date|: date of procurement.
	\item \verb|procured_price|: price of the product as procured.
	\item \verb|payment_method_id|: payment method.
	\item \verb|warranty_date_1|: warranty expiration date (free replace or repair); leave it as the procured date if no such warranty is issued.
	\item \verb|warranty_date_2|: second warranty expiration date (partially covered repair); leave it as the procured date if no such warranty is issued.
	\item \verb|expire_date|: the date when the asset expires or needs to be returned. For example, in Singapore a car ``expires'' in 10 years from the day of procurement.
\end{itemize}
Notice that constraints and default values have been added to the table creation. An SQL script is used contain the code, and
\begin{lstlisting}
	$ mariadb -u <user-name> -p < <script-name>
\end{lstlisting}
is used to execute the script, which is more convinient than typing all the lines in the MariaDB console.

Similarly, create the rest 3 tables for the resources as follows.
\begin{lstlisting}
CREATE TABLE accessory (
	PRIMARY KEY (item_id),
	item_id                     INT(5)          AUTO_INCREMENT,
	product_type_id             INT(5),
	product_brand_id            INT(5),
	product_name                VARCHAR(50)     NOT NULL,
	receipt_num                 VARCHAR(50),
	procured_date               DATE            NOT NULL DEFAULT (CURRENT_DATE),
	procured_number             DECIMAL(10,2)   NOT NULL DEFAULT 1.00,
	procured_unit_price         DECIMAL(10,2),
	procured_price              DECIMAL(10,2),
	payment_method_id           INT(5),
	expire_date                 DATE            NOT NULL DEFAULT '9999-12-31',
	CONSTRAINT expire_after_procured
	CHECK(expire_date >= procured_date)
);
	
CREATE TABLE consumable (
	PRIMARY KEY (item_id),
	item_id                     INT(5)          AUTO_INCREMENT,
	product_type_id             INT(5),
	product_brand_id            INT(5),
	product_name                VARCHAR(50)     NOT NULL,
	receipt_num                 VARCHAR(50),
	procured_date               DATE            NOT NULL DEFAULT (CURRENT_DATE),
	procured_number             DECIMAL(10,2)   NOT NULL DEFAULT 1.00,
	procured_unit_price         DECIMAL(10,2),
	procured_price              DECIMAL(10,2),
	payment_method_id           INT(5),
	expire_date                 DATE            NOT NULL DEFAULT (CURRENT_DATE),
	CONSTRAINT expire_after_procured
	CHECK(expire_date >= procured_date)
);
	
CREATE TABLE subscription (
	PRIMARY KEY (item_id),
	item_id                     INT(5)          AUTO_INCREMENT,
	product_type_id             INT(5),
	product_brand_id            INT(5),
	product_name                VARCHAR(50)     NOT NULL,
	receipt_num                 VARCHAR(50),
	procured_date               DATE            NOT NULL DEFAULT (CURRENT_DATE),
	procured_price              DECIMAL(10,2),
	payment_method_id           INT(5),
	expire_date                 DATE            NOT NULL DEFAULT (CURRENT_DATE),
	CONSTRAINT expire_after_procured
	CHECK(expire_date >= procured_date)
);
\end{lstlisting}

Create the tables for users, product types, product brands and payment methods as follows.
\begin{lstlisting}
CREATE TABLE user (
	PRIMARY KEY (user_id),
	user_id                     INT(5),
	first_name                  VARCHAR(50)     NOT NULL,
	last_name                   VARCHAR(50)     NOT NULL,
	email                       VARCHAR(50)     NOT NULL UNIQUE
);
	
CREATE TABLE product_type (
	PRIMARY KEY (product_type_id),
	product_type_id             INT(5)          AUTO_INCREMENT,
	product_type_name           VARCHAR(50)     NOT NULL UNIQUE,
	product_type_name_sub       VARCHAR(50)     NOT NULL DEFAULT ('na')
);
	
CREATE TABLE product_brand (
	PRIMARY KEY (product_brand_id),
	product_brand_id            INT(5)          AUTO_INCREMENT,
	product_brand_name          VARCHAR(50)     NOT NULL UNIQUE
);
	
CREATE TABLE payment_method (
	PRIMARY KEY (payment_method_id),
	payment_method_id           INT(50)         AUTO_INCREMENT,
	user_id                     INT(5),
	payment_method_name         VARCHAR(50)     NOT NULL
);
\end{lstlisting}

Finally, create foreign keys as follows.
\begin{lstlisting}
ALTER TABLE payment_method
ADD FOREIGN KEY (user_id)
REFERENCES user(user_id);
ALTER TABLE asset
ADD FOREIGN KEY (product_type_id)
REFERENCES product_type(product_type_id);
ALTER TABLE asset
ADD FOREIGN KEY (product_brand_id)
REFERENCES product_brand(product_brand_id);
ALTER TABLE asset
ADD FOREIGN KEY (payment_method_id)
REFERENCES payment_method(payment_method_id);
ALTER TABLE accessory
ADD FOREIGN KEY (product_type_id)
REFERENCES product_type(product_type_id);
ALTER TABLE accessory
ADD FOREIGN KEY (product_brand_id)
REFERENCES product_brand(product_brand_id);
ALTER TABLE accessory
ADD FOREIGN KEY (payment_method_id)
REFERENCES payment_method(payment_method_id);
ALTER TABLE consumable
ADD FOREIGN KEY (product_type_id)
REFERENCES product_type(product_type_id);
ALTER TABLE consumable
ADD FOREIGN KEY (product_brand_id)
REFERENCES product_brand(product_brand_id);
ALTER TABLE consumable
ADD FOREIGN KEY (payment_method_id)
REFERENCES payment_method(payment_method_id);
ALTER TABLE subscription
ADD FOREIGN KEY (product_type_id)
REFERENCES product_type(product_type_id);
ALTER TABLE subscription
ADD FOREIGN KEY (product_brand_id)
REFERENCES product_brand(product_brand_id);
ALTER TABLE subscription
ADD FOREIGN KEY (payment_method_id)
REFERENCES payment_method(payment_method_id);
\end{lstlisting}

\section{General Ways to Connect to RDB}

This section discusses the tools or program interfaces used along with the DBMS. Many software programs provide interface or toolkit to connect to a database. For example, MATLAB uses database toolbox to connect to SQLite or Microsoft SQL server. Python, as a ``glue'' language, also provide variety of packages to connect to different databases. IDEs such as VSCode can connect to databases using extensions.

Python provides variety of libraries to access RDS, many of which use embedded SQL codes to interact with the DBMS. Depending on the DBMS, different libraries and commands can be used, some of which more general and the other more specific to a particular DBMS.

In this section, both \verb|pandas| and \verb|mariadb| libraries are introduced. The \verb|pandas| library provides data manipulation and analysis tools, and it provides \verb|pandas.io.sql| that allows connecting to a DBMS and embedding SQL commands into the python code. The \verb|mariadb| library, on the other hand, is dedicated for MariaDB connection. Like \verb|pandas.io.sql|, it also allows embedding SQL commands to interface the DMBS.

As pre-requisitions, make sure that the following has been done.
\begin{itemize}
	\item The DBMS has been configured to allow remote access.
	\item Make sure that an account has been registered in DBMS that has the privilege of operation from a remote machine.
	\item Make sure that the firewall configuration is correct.
\end{itemize}

For DBMS configuration, in the case of MariaDB, use the following code in the shell to check the location of the configuration files.
\begin{lstlisting}
$ mysqld --help --verbose
\end{lstlisting}
Typical locations of the configuration files are \verb|/etc/my.cnf| and \verb|/etc/mysql/my.cnf|. In the configuration file, use the following to disable binding address.
\begin{lstlisting}
[mysqld]
skip-networking=0
skip-bind-address
\end{lstlisting}

For account setup, in the DBMS console, use something like
\begin{lstlisting}
> GRANT ALL PRIVILEGES ON *.* TO '<user-name>'@'<ip-address>' IDENTIFIED BY '<user-password>' WITH GRANT OPTION;
\end{lstlisting}
where \verb|'<ip-address>'| is the remote machine that runs the Python program. If the Python codes are running locally, simply use \verb|'localhost'|.

It might be necessary to install MariaDB database development files in the DMBS host machine for the Python libraries to be introduced to function properly. Install the development as follows.
\begin{lstlisting}
	$ sudo apt install libmariadb-dev
\end{lstlisting}

\vspace{0.1in}
\noindent \textbf{PANDAS Library}
\vspace{0.1in}

Python library \verb|pandas| is one of the essential libraries for data analysis. It provides flexible interfaces and tools for data reading and processing and works very well with different data formats and engines including CSV, EXCEL and DBMS. This section focuses mainly on the interaction of \verb|pandas| with DBMS. Therefore, the detailed use of \verb|pandas| for data analysis, etc., are not covered in this section.

A class \verb|pandas.DataFrame| is defined in \verb|pandas| as the backbone to store and process data. The data attribute of \verb|pandas.DataFrame| is a \verb|numpy| array. Many functions are provided to read different data formats into \verb|pandas| data frame, which makes reading data easy and convenient. An example of reading a CSV file is given below.
\begin{lstlisting}
import pandas as pd
df = pd.read_csv(<file-name>)
print(df)
print(df.head(<number>))
print(df.tail(<number>))
print(df.info())
\end{lstlisting}
where \verb|head()|, \verb|tail()| gives the first and last rows of the data frame, and \verb|info()| checks the data frame basic information including shape and data types of the columns. Check \verb|df.columns| for all the columns of the data frame. Details specific to a column can be accessed via \verb|df.[<column-name>]|. Many functions are provided to further abstract the details, such as grouping and counting. Use \verb|df.loc(<row-index-list>, <column-name-list>)| to check the content of specified rows and columns.

With \verb|pandas| and other relavent libraries, Python can connect to a database and execute a query. An example of using \verb|pandas| to connect to an Microsoft SQL server and implement a query is given below. Notice that different DBMS may require different database connectivity driver standards, and there are mainly two of them, namely open database connectivity (ODBC) and Java database connectivity (JDBC). Microsoft adopts ODBC, and a separate package is required in the Python program to connect to the Microsoft SQL server.
\begin{lstlisting}
import pyodbc
import pandas.io.sql as psql

server = "<server-url>,<port>"
database = "<database>"
uid = "<uid>"
pwd = "<pwd>"
driver = "<driver>" # such as "{ODBC Driver 17 for SQL Server}"

# connect to database
conn = pyodbc.connect(
server = server,
database = database,
uid = uid,
pwd = pwd,
driver = driver
)

# get cursor
cursor = conn.cursor()

# execute sql command
query = """<query>"""
runs = psql.read_sql_query(query, conn)
\end{lstlisting}
The above codes returns a data frame corresponding to the result set of the query string, which is saved in \verb|runs|.

\vspace{0.1in}
\noindent \textbf{MARIADB Library}
\vspace{0.1in}

Use the following code to test connectivity from Python to the database.
\begin{lstlisting}
import mariadb
import sys

user = "<user>"
password = "<password>"
host = "<server-url>"
port = "<port>" # MariaDB default: 3306
database = "<database>"

# connect to database
try:
conn = mariadb.connect(
user = user,
password = password,
host = host,
port = port,
database = database
)
except mariadb.Error as e:
print(f"Error connecting to MariaDB Platform: {e}")
sys.exit(1)

# get cursor
cur = conn.cursor()

# execute sql command
cur.execute("<sql-command>")
\end{lstlisting}
Notice that for query, the result is stored in the cursor object. Use a for loop to view the results.

